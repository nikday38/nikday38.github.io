<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Compare Pro | Умный анализ</title>
    <style>
        /* ... (все стили остаются без изменений) ... */
    </style>
</head>
<body>
    <!-- ... (весь HTML код остается без изменений) ... -->

    <script>
        // ... (остальной код без изменений) ...

        function analyzeImages(sensitivity, minArea) {
            try {
                updateProgress(10, 'Подготовка изображений...');

                const canvas1 = document.createElement('canvas');
                const canvas2 = document.createElement('canvas');
                const ctx1 = canvas1.getContext('2d');
                const ctx2 = canvas2.getContext('2d');

                const width = 800;
                const height = Math.floor((width / image1.naturalWidth) * image1.naturalHeight);

                canvas1.width = canvas2.width = width;
                canvas1.height = canvas2.height = height;

                updateProgress(30, 'Обработка изображений...');
                ctx1.drawImage(image1, 0, 0, width, height);
                ctx2.drawImage(image2, 0, 0, width, height);

                updateProgress(50, 'Анализ структурных различий...');
                
                const imageData1 = ctx1.getImageData(0, 0, width, height);
                const imageData2 = ctx2.getImageData(0, 0, width, height);
                const data1 = imageData1.data;
                const data2 = imageData2.data;

                // НОВЫЙ АЛГОРИТМ - структурный анализ
                const diffMap = new Uint8ClampedArray(width * height);
                let structuralDifferences = 0;
                const blockSize = 8; // Анализируем блоками 8x8 пикселей

                for (let y = 0; y < height - blockSize; y += blockSize) {
                    for (let x = 0; x < width - blockSize; x += blockSize) {
                        let blockDifference = 0;
                        let blockPixels = 0;

                        // Анализируем каждый блок
                        for (let by = 0; by < blockSize; by++) {
                            for (let bx = 0; bx < blockSize; bx++) {
                                const px = x + bx;
                                const py = y + by;
                                const idx = (py * width + px) * 4;
                                
                                const r1 = data1[idx];
                                const g1 = data1[idx + 1];
                                const b1 = data1[idx + 2];
                                
                                const r2 = data2[idx];
                                const g2 = data2[idx + 1];
                                const b2 = data2[idx + 2];

                                // Более точная формула различия
                                const diff = Math.sqrt(
                                    Math.pow(r1 - r2, 2) * 0.3 +
                                    Math.pow(g1 - g2, 2) * 0.59 +
                                    Math.pow(b1 - b2, 2) * 0.11
                                );

                                if (diff > sensitivity * 100) { // Умножаем на 100 для точности
                                    blockDifference++;
                                }
                                blockPixels++;
                            }
                        }

                        // Если в блоке достаточно различий, помечаем весь блок
                        if (blockDifference > blockPixels * 0.3) { // 30% различий в блоке
                            structuralDifferences += blockPixels;
                            for (let by = 0; by < blockSize; by++) {
                                for (let bx = 0; bx < blockSize; bx++) {
                                    const px = x + bx;
                                    const py = y + by;
                                    if (px < width && py < height) {
                                        diffMap[py * width + px] = 255;
                                    }
                                }
                            }
                        }
                    }
                    updateProgress(50 + (y / height * 30), `Анализ: ${Math.round(y / height * 100)}%`);
                }

                updateProgress(80, 'Поиск значимых областей...');
                
                differenceAreas = findConnectedComponents(diffMap, width, height, minArea);

                updateProgress(90, 'Создание результата...');
                
                const resultCanvas = document.createElement('canvas');
                resultCanvas.width = width;
                resultCanvas.height = height;
                const resultCtx = resultCanvas.getContext('2d');
                
                resultCtx.drawImage(canvas1, 0, 0);

                // Подсвечиваем различия
                resultCtx.strokeStyle = '#ff4757';
                resultCtx.lineWidth = 3;
                resultCtx.fillStyle = 'rgba(255, 71, 87, 0.2)';
                
                let totalChangedPixels = 0;
                differenceAreas.forEach(area => {
                    totalChangedPixels += area.length;
                    let minX = width, minY = height, maxX = 0, maxY = 0;
                    for (const [x, y] of area) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }

                    resultCtx.beginPath();
                    resultCtx.rect(minX, minY, maxX - minX, maxY - minY);
                    resultCtx.stroke();
                    resultCtx.fill();
                });

                // НОВЫЙ РАСЧЕТ СХОЖЕСТИ - учитывает вес различий
                const totalPixels = width * height;
                
                // Учитываем не только количество пикселей, но и их значимость
                let weightedDifference = 0;
                differenceAreas.forEach(area => {
                    // Большие области имеют больший вес
                    let minX = width, minY = height, maxX = 0, maxY = 0;
                    for (const [x, y] of area) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                    const areaSize = (maxX - minX) * (maxY - minY);
                    // Центральные области имеют больший вес
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    const centerWeight = 1 + (1 - Math.abs(centerX - width/2) / (width/2)) * 0.5;
                    
                    weightedDifference += area.length * centerWeight * (1 + Math.log1p(areaSize / 100));
                });

                const similarity = Math.max(0, 100 - (weightedDifference / totalPixels * 100 * 2));
                const similarityRounded = Math.round(similarity * 10) / 10;

                analysisResult = {
                    similarity: similarityRounded,
                    diffCanvas: resultCanvas,
                    totalPixels: totalPixels,
                    changedPixels: totalChangedPixels,
                    areasCount: differenceAreas.length,
                    analysisTime: ((Date.now() - startTime) / 1000).toFixed(1),
                    resolution: `${width}×${height}px`,
                    weightedDifference: Math.round(weightedDifference)
                };

                updateProgress(100, 'Анализ завершен!');
                
                setTimeout(() => {
                    document.getElementById('progress-container').style.display = 'none';
                    displayResult();
                }, 500);

            } catch (error) {
                console.error('Analysis error:', error);
                showError('Ошибка анализа: ' + error.message);
                document.getElementById('progress-container').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
            }
        }

        function displayResult() {
            if (!analysisResult) return;

            // ... (код отображения результатов) ...

            detailedStats.innerHTML = `
                <p><strong>Разрешение анализа:</strong> ${analysisResult.resolution}</p>
                <p><strong>Всего пикселей:</strong> ${analysisResult.totalPixels.toLocaleString()}</p>
                <p><strong>Измененные пиксели:</strong> ${analysisResult.changedPixels.toLocaleString()}</p>
                <p><strong>Взвешенные различия:</strong> ${analysisResult.weightedDifference.toLocaleString()}</p>
                <p><strong>Областей различий:</strong> ${analysisResult.areasCount}</p>
                <p><strong>Реальная схожесть:</strong> ${analysisResult.similarity.toFixed(2)}%</p>
                <p><strong>Время анализа:</strong> ${analysisResult.analysisTime} сек</p>
                <p><strong>Метод:</strong> Взвешенный структурный анализ</p>
            `;

            // ... (остальной код) ...
        }
    </script>
</body>
</html>
