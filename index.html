<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copyright Control Pro</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #2c3e50;
            margin: 0;
            font-size: 2.5em;
        }
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
            }
        }
        .upload-box {
            border: 3px dashed #3498db;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .preview-container {
            margin-top: 15px;
            text-align: center;
        }
        .preview-container img {
            max-width: 100%;
            max-height: 150px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }
        .slider-container {
            margin: 15px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #2c3e50;
        }
        .slider-value {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            font-weight: bold;
            color: #3498db;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        .button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        .button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        .button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        .button-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }
        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        .result-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        .similarity-score {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }
        .high-similarity { color: #e74c3c; }
        .medium-similarity { color: #f39c12; }
        .low-similarity { color: #27ae60; }
        .verdict {
            font-size: 1.2em;
            font-weight: 600;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }
        canvas {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin: 10px 0;
        }
        .loading {
            text-align: center;
            padding: 30px;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
        }
        .info {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Copyright Control Pro</h1>
            <p>–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –ø–ª–∞–≥–∏–∞—Ç–∞</p>
        </div>

        <div class="info">
            <strong>üöÄ –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º:</strong> –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ—Ä–æ–≥–∏, —Ä–∞–∑–º—ã—Ç–∏–µ –∏ –º–æ—Ä—Ñ–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö —Ä–∞–∑–ª–∏—á–∏–π –±–µ–∑ —à—É–º–∞.
        </div>

        <div class="upload-section">
            <div class="upload-box" onclick="document.getElementById('file-input1').click()">
                <div>üìÅ</div>
                <p>–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</p>
                <div class="preview-container" id="preview1"></div>
            </div>

            <div class="upload-box" onclick="document.getElementById('file-input2').click()">
                <div>üìÅ</div>
                <p>–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏</p>
                <div class="preview-container" id="preview2"></div>
            </div>
        </div>

        <input type="file" id="file-input1" accept="image/*" onchange="handleFileSelect(this, 'preview1')" style="display: none;">
        <input type="file" id="file-input2" accept="image/*" onchange="handleFileSelect(this, 'preview2')" style="display: none;">

        <div class="controls">
            <h3>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–æ—á–Ω–æ—Å—Ç–∏</h3>
            
            <div class="slider-container">
                <label>
                    –ü–æ—Ä–æ–≥ —Ä–∞–∑–ª–∏—á–∏–π: <span class="slider-value" id="threshold-value">50</span>%
                    <input type="range" id="threshold" min="10" max="100" value="50" onchange="updateSliderValue('threshold', 'threshold-value')">
                </label>
            </div>

            <div class="slider-container">
                <label>
                    –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: <span class="slider-value" id="sensitivity-value">5</span>
                    <input type="range" id="sensitivity" min="1" max="20" value="5" onchange="updateSliderValue('sensitivity', 'sensitivity-value')">
                </label>
            </div>

            <div class="slider-container">
                <label>
                    –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ–±–ª–∞—Å—Ç–∏: <span class="slider-value" id="min-area-value">100</span>px¬≤
                    <input type="range" id="min-area" min="10" max="500" value="100" onchange="updateSliderValue('min-area', 'min-area-value')">
                </label>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="button" id="compare-btn" onclick="compareImages()" disabled>üîç –ù–∞—á–∞—Ç—å –∞–Ω–∞–ª–∏–∑</button>
                <button class="button button-secondary" onclick="resetAnalysis()">üîÑ –°–±—Ä–æ—Å–∏—Ç—å</button>
            </div>
        </div>

        <div id="loading" style="display: none;">
            <div class="loading">
                <div class="spinner"></div>
                <p>–í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π...</p>
                <p>–≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥</p>
            </div>
        </div>

        <div id="error-message" class="error" style="display: none;"></div>

        <div id="result" style="display: none;">
            <h2 style="text-align: center; margin-bottom: 30px;">üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞</h2>
            
            <div class="results-grid">
                <div class="result-card">
                    <h3>–û–±—â–∞—è —Å—Ö–æ–∂–µ—Å—Ç—å</h3>
                    <div class="similarity-score" id="similarity-score">0%</div>
                    <div class="verdict" id="verdict"></div>
                    <p>–ù–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞ –ø–∏–∫—Å–µ–ª–µ–π –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã—Ö –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π</p>
                </div>

                <div class="result-card">
                    <h3>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑–ª–∏—á–∏–π</h3>
                    <canvas id="diff-canvas"></canvas>
                    <p>–ö—Ä–∞—Å–Ω—ã–º –≤—ã–¥–µ–ª–µ–Ω—ã –∑–Ω–∞—á–∏–º—ã–µ –æ–±–ª–∞—Å—Ç–∏ —Ä–∞–∑–ª–∏—á–∏–π</p>
                </div>
            </div>

            <div class="result-card" style="margin-top: 20px;">
                <h3>üìà –î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
                <div id="stats" style="text-align: left; line-height: 1.6;"></div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="button" onclick="saveResult()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
                <button class="button button-secondary" onclick="resetAnalysis()">üîÑ –ù–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑</button>
            </div>
        </div>
    </div>

    <script>
        let image1 = null;
        let image2 = null;
        let analysisResult = null;

        function updateSliderValue(sliderId, valueId) {
            const slider = document.getElementById(sliderId);
            const value = document.getElementById(valueId);
            value.textContent = slider.value;
        }

        function handleFileSelect(input, previewId) {
            const file = input.files[0];
            if (!file || !file.type.match('image.*')) {
                showError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
                return;
            }

            hideError();
            const reader = new FileReader();
            reader.onload = function(e) {
                const preview = document.getElementById(previewId);
                const img = document.createElement('img');
                img.src = e.target.result;
                img.style.maxWidth = '100%';
                img.style.maxHeight = '150px';
                
                preview.innerHTML = '';
                preview.appendChild(img);
                
                if (previewId === 'preview1') {
                    image1 = img;
                } else {
                    image2 = img;
                }
                
                checkButtonState();
            };
            reader.readAsDataURL(file);
        }

        function checkButtonState() {
            const btn = document.getElementById('compare-btn');
            btn.disabled = !(image1 && image2);
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
        }

        function applyGaussianBlur(ctx, imageData, radius) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const tempData = new Uint8ClampedArray(data);
            
            const kernel = createGaussianKernel(radius);
            const half = Math.floor(kernel.length / 2);
            
            // Apply horizontal blur
            for (let y = 0; y < height; y++) {
                for (let x = half; x < width - half; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let i = -half; i <= half; i++) {
                        const idx = ((y * width) + (x + i)) * 4;
                        const weight = kernel[i + half];
                        r += tempData[idx] * weight;
                        g += tempData[idx + 1] * weight;
                        b += tempData[idx + 2] * weight;
                    }
                    const idx = ((y * width) + x) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                }
            }
            
            // Apply vertical blur
            const tempData2 = new Uint8ClampedArray(data);
            for (let y = half; y < height - half; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let i = -half; i <= half; i++) {
                        const idx = (((y + i) * width) + x) * 4;
                        const weight = kernel[i + half];
                        r += tempData2[idx] * weight;
                        g += tempData2[idx + 1] * weight;
                        b += tempData2[idx + 2] * weight;
                    }
                    const idx = ((y * width) + x) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                }
            }
            
            return imageData;
        }

        function createGaussianKernel(radius) {
            const size = radius * 2 + 1;
            const kernel = new Array(size);
            const sigma = radius / 3;
            let sum = 0;
            
            for (let i = -radius; i <= radius; i++) {
                const weight = Math.exp(-(i * i) / (2 * sigma * sigma)) / (Math.sqrt(2 * Math.PI) * sigma);
                kernel[i + radius] = weight;
                sum += weight;
            }
            
            // Normalize kernel
            for (let i = 0; i < size; i++) {
                kernel[i] /= sum;
            }
            
            return kernel;
        }

        function findContours(binaryData, width, height, minArea) {
            const visited = new Array(width * height).fill(false);
            const contours = [];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (binaryData[idx] === 255 && !visited[idx]) {
                        const contour = [];
                        const queue = [[x, y]];
                        visited[idx] = true;
                        
                        while (queue.length > 0) {
                            const [cx, cy] = queue.shift();
                            contour.push([cx, cy]);
                            
                            // Check 8-connected neighbors
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    
                                    const nx = cx + dx;
                                    const ny = cy + dy;
                                    
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        const nidx = ny * width + nx;
                                        if (binaryData[nidx] === 255 && !visited[nidx]) {
                                            visited[nidx] = true;
                                            queue.push([nx, ny]);
                                        }
                                    }
                                }
                            }
                        }
                        
                        if (contour.length >= minArea) {
                            contours.push(contour);
                        }
                    }
                }
            }
            
            return contours;
        }

        function compareImages() {
            if (!image1 || !image2) return;

            const threshold = parseInt(document.getElementById('threshold').value);
            const sensitivity = parseInt(document.getElementById('sensitivity').value);
            const minArea = parseInt(document.getElementById('min-area').value);

            document.getElementById('loading').style.display = 'block';
            document.getElementById('result').style.display = 'none';
            hideError();

            setTimeout(() => {
                try {
                    // Create canvases
                    const canvas1 = document.createElement('canvas');
                    const canvas2 = document.createElement('canvas');
                    const ctx1 = canvas1.getContext('2d');
                    const ctx2 = canvas2.getContext('2d');

                    // Set dimensions (resize for performance)
                    const scale = 0.5;
                    const width = Math.min(image1.naturalWidth, image2.naturalWidth) * scale;
                    const height = Math.min(image1.naturalHeight, image2.naturalHeight) * scale;

                    canvas1.width = canvas2.width = width;
                    canvas1.height = canvas2.height = height;

                    // Draw images
                    ctx1.drawImage(image1, 0, 0, width, height);
                    ctx2.drawImage(image2, 0, 0, width, height);

                    // Get image data
                    const imageData1 = ctx1.getImageData(0, 0, width, height);
                    const imageData2 = ctx2.getImageData(0, 0, width, height);

                    // Apply Gaussian blur to reduce noise
                    const blurred1 = applyGaussianBlur(ctx1, imageData1, sensitivity);
                    const blurred2 = applyGaussianBlur(ctx2, imageData2, sensitivity);

                    const data1 = blurred1.data;
                    const data2 = blurred2.data;

                    // Create difference map
                    const diffData = new Uint8ClampedArray(width * height);
                    let differentPixels = 0;

                    for (let i = 0; i < data1.length; i += 4) {
                        const r1 = data1[i];
                        const g1 = data1[i + 1];
                        const b1 = data1[i + 2];
                        
                        const r2 = data2[i];
                        const g2 = data2[i + 1];
                        const b2 = data2[i + 2];

                        // Calculate perceptual difference
                        const diff = Math.sqrt(
                            Math.pow(r1 - r2, 2) +
                            Math.pow(g1 - g2, 2) +
                            Math.pow(b1 - b2, 2)
                        ) / Math.sqrt(3 * 255 * 255);

                        if (diff > threshold / 100) {
                            diffData[i / 4] = 255;
                            differentPixels++;
                        } else {
                            diffData[i / 4] = 0;
                        }
                    }

                    // Find significant contours
                    const contours = findContours(diffData, width, height, minArea);

                    // Calculate similarity
                    const similarity = ((width * height - differentPixels) / (width * height)) * 100;
                    const similarityRounded = Math.round(similarity * 100) / 100;

                    // Create result visualization
                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = width;
                    resultCanvas.height = height;
                    const resultCtx = resultCanvas.getContext('2d');
                    
                    // Draw original image
                    resultCtx.drawImage(image1, 0, 0, width, height);
                    
                    // Draw contours
                    resultCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    resultCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                    resultCtx.lineWidth = 2;
                    
                    for (const contour of contours) {
                        resultCtx.beginPath();
                        for (let i = 0; i < contour.length; i++) {
                            const [x, y] = contour[i];
                            if (i === 0) {
                                resultCtx.moveTo(x, y);
                            } else {
                                resultCtx.lineTo(x, y);
                            }
                        }
                        resultCtx.closePath();
                        resultCtx.fill();
                        resultCtx.stroke();
                    }

                    analysisResult = {
                        similarity: similarityRounded,
                        diffCanvas: resultCanvas,
                        contours: contours.length,
                        totalPixels: width * height,
                        differentPixels: differentPixels
                    };

                    displayResult();

                } catch (error) {
                    console.error('Analysis error:', error);
                    showError('–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: ' + error.message);
                } finally {
                    document.getElementById('loading').style.display = 'none';
                }
            }, 100);
        }

        function displayResult() {
            if (!analysisResult) return;

            const similarityScore = document.getElementById('similarity-score');
            const verdict = document.getElementById('verdict');
            const diffCanvas = document.getElementById('diff-canvas');
            const stats = document.getElementById('stats');

            similarityScore.textContent = analysisResult.similarity + '%';
            
            let verdictText = '';
            let verdictClass = '';
            
            if (analysisResult.similarity >= 95) {
                verdictText = 'üö® –í–ï–†–û–Ø–¢–ù–û –ü–û–õ–ù–´–ô –ü–õ–ê–ì–ò–ê–¢';
                verdictClass = 'high-similarity';
            } else if (analysisResult.similarity >= 85) {
                verdictText = '‚ö†Ô∏è –í–´–°–û–ö–ê–Ø –°–¢–ï–ü–ï–ù–¨ –°–•–û–î–°–¢–í–ê';
                verdictClass = 'high-similarity';
            } else if (analysisResult.similarity >= 70) {
                verdictText = 'üîç –ó–ù–ê–ß–ò–¢–ï–õ–¨–ù–û–ï –°–•–û–î–°–¢–í–û';
                verdictClass = 'medium-similarity';
            } else if (analysisResult.similarity >= 50) {
                verdictText = 'üìä –£–ú–ï–†–ï–ù–ù–û–ï –°–•–û–î–°–¢–í–û';
                verdictClass = 'medium-similarity';
            } else {
                verdictText = '‚úÖ –ó–ù–ê–ß–ò–¢–ï–õ–¨–ù–´–ï –†–ê–ó–õ–ò–ß–ò–Ø';
                verdictClass = 'low-similarity';
            }

            similarityScore.className = 'similarity-score ' + verdictClass;
            verdict.textContent = verdictText;
            verdict.className = 'verdict ' + verdictClass;

            // Draw difference visualization
            const ctx = diffCanvas.getContext('2d');
            diffCanvas.width = analysisResult.diffCanvas.width;
            diffCanvas.height = analysisResult.diffCanvas.height;
            ctx.drawImage(analysisResult.diffCanvas, 0, 0);

            // Display statistics
            stats.innerHTML = `
                <p>‚Ä¢ <strong>–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∏–∫—Å–µ–ª–µ–π:</strong> ${analysisResult.totalPixels.toLocaleString()}</p>
                <p>‚Ä¢ <strong>–†–∞–∑–ª–∏—á–∞—é—â–∏–µ—Å—è –ø–∏–∫—Å–µ–ª–∏:</strong> ${analysisResult.differentPixels.toLocaleString()}</p>
                <p>‚Ä¢ <strong>–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∑–Ω–∞—á–∏–º—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π:</strong> ${analysisResult.contours}</p>
                <p>‚Ä¢ <strong>–ü—Ä–æ—Ü–µ–Ω—Ç —Ä–∞–∑–ª–∏—á–∏–π:</strong> ${(100 - analysisResult.similarity).toFixed(2)}%</p>
                <p>‚Ä¢ <strong>–£—Ä–æ–≤–µ–Ω—å —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏:</strong> –í—ã—Å–æ–∫–∏–π (–∞–ª–≥–æ—Ä–∏—Ç–º —Å –ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ–º —à—É–º–∞)</p>
            `;

            document.getElementById('result').style.display = 'block';
        }

        function resetAnalysis() {
            image1 = null;
            image2 = null;
            analysisResult = null;
            document.getElementById('preview1').innerHTML = '';
            document.getElementById('preview2').innerHTML = '';
            document.getElementById('result').style.display = 'none';
            document.getElementById('compare-btn').disabled = true;
            hideError();
        }

        function saveResult() {
            if (!analysisResult) return;
            
            const link = document.createElement('a');
            link.download = 'copyright-analysis-result.png';
            link.href = document.getElementById('diff-canvas').toDataURL();
            link.click();
        }
    </script>
</body>
</html>
